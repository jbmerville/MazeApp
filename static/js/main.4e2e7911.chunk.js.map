{"version":3,"sources":["Cell.js","Grid.js","Button.js","SideBar.js","Tutorial.js","index.js"],"names":["Cell","props","toWall","bind","lock","click","drag","makeCurrent","state","node","hold","locked","dxrag","dragType","lockAll","current","prevProps","prevState","this","setState","type","bool","className","onMouseEnter","onMouseLeave","e","onClick","onMouseDown","onMouseOver","React","Component","Grid","down","event","solved","resetNodeOfTypes","up","grid","row","col","reset","sleep","recursiveBacktracking","depthFirstSearch","aStar","dijkstra","iterativeRandom","BFS","recursiveDivision","recursiveDivision2","clearAroundNode","randomNumber","height","width","prev","i","j","g","h","f","d","push","start","getStart","end","getEnd","queue","parent","length","curr","shift","neighbors","getUnvisitedNeighbors","neighbor","obj","includes","removeFromArray","openSet","closedSet","path","winner","tempG","heuristic","newPath","previous","temp","depthFirstSearchHelper","cur","a","stack","rand","Math","floor","random","pop","types","addEntrance","x","addInnerWalls","minX","maxX","minY","maxY","gate","y","addHWall","addVWall","hole","min","max","ent","buildWall","vert","hori","horiWall","vertWall","vertAndHor","leftHole","rightHole","z","count","topHole","botHole","newHoles","newQueue","getNode","time","Promise","resolve","setTimeout","includeEnd","includeStart","arr","elt","splice","b","ver","abs","hor","sqrt","onMouseUp","map","rowIdx","key","nodeIdx","Button","name","split","text","SideBar","switchColors","swapCSSvar","property","getComputedStyle","document","documentElement","getPropertyValue","style","setProperty","Tutorial","size","App","ref","createRef","window","innerWidth","innerHeight","margin","ReactDOM","render","querySelector"],"mappings":"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","file":"static/js/main.4e2e7911.chunk.js","sourcesContent":["import React from \"react\";\n\nclass Cell extends React.Component {\n    constructor(props) {\n        super(props);\n        this.toWall = this.toWall.bind(this);\n        this.lock = this.lock.bind(this);\n        this.click = this.click.bind(this);\n        this.drag = this.drag.bind(this);\n        this.makeCurrent = this.makeCurrent.bind(this);\n        this.state = {\n            node: props.node,\n            hold: props.hold,\n            locked: true,\n            drag: props.dxrag,\n            dragType: props.dragType,\n            lockAll: props.lockAll,\n            current: props.current,\n        };\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n        if (prevProps.hold !== this.props.hold) {\n            this.setState({ hold: this.props.hold, drag: this.props.drag, dragType: this.props.dragType });\n        }\n        if (prevProps.node !== this.props.node) {\n            this.setState({ node: this.props.node });\n        }\n    }\n\n    // Changes the nodes \n    toWall() {\n        const { hold, locked, dragType, node } = this.state;\n        if (!hold  && locked) {\n            if (node.type === \"unvisited\") {\n                node.type = dragType === null ? \"wall\" : dragType;\n                this.setState({ node });\n            } else if (node.type === \"wall\") {\n                node.type = dragType === null ? \"unvisited\" : dragType;\n                this.setState({ node });\n            }\n        } \n    }\n\n\n    lock(bool) {\n        const { hold, dragType, node } = this.state;\n        if (!hold) {\n            if (dragType !== null) node.type = \"unvisited\";\n            this.setState({ locked: bool });\n        } \n    }\n\n    // Turn on and off walls on click.\n    click() {\n        if (this.state.node.type === \"unvisited\") {\n            let node = this.state.node;\n            node.type = \"wall\";\n            this.setState({ node: node });\n        } else if (this.state.node.type === \"wall\") {\n            let node = this.state.node;\n            node.type = \"unvisited\";\n            this.setState({ node: node });\n        }\n    }\n\n    // Drag the start and end nodes.\n    drag() {\n        const { node, lockAll } = this.state;\n        lockAll(node.type);\n        this.setState({ node });\n    }\n\n    // Update which node the user is currently hovering.\n    makeCurrent() {\n        this.state.current(this.state.node);\n    }\n\n    render() {\n        if (this.state.node.type === \"start\" || this.state.node.type === \"end\") {\n            return (\n                <td\n                    className={\"cell \" + this.state.node.type}\n                    onMouseEnter={this.toWall}\n                    onMouseLeave={(e) => this.lock(true)}\n                    onClick={this.click}\n                    onMouseDown={this.drag}\n                    onMouseOver={this.makeCurrent}\n                ></td>\n            );\n        }\n\n        return (\n            <td\n                className={\"cell \" + this.state.node.type}\n                onMouseEnter={this.toWall}\n                onMouseLeave={(e) => this.lock(true)}\n                onClick={this.click}\n                onMouseOver={this.makeCurrent}\n            ></td>\n        );\n    }\n}\n\nexport default Cell;\n","import React from \"react\";\nimport Cell from \"./Cell\";\n\nclass Grid extends React.Component {\n    constructor(props) {\n        super(props);\n        this.makeCurrent = this.makeCurrent.bind(this);\n        this.reset = this.reset.bind(this);\n        this.sleep = this.sleep.bind(this);\n        this.recursiveBacktracking = this.recursiveBacktracking.bind(this);\n        this.depthFirstSearch = this.depthFirstSearch.bind(this);\n        this.aStar = this.aStar.bind(this);\n        this.dijkstra = this.dijkstra.bind(this);\n        this.iterativeRandom = this.iterativeRandom.bind(this);\n        this.BFS = this.BFS.bind(this);\n        this.recursiveDivision = this.recursiveDivision.bind(this);\n        this.recursiveDivision2 = this.recursiveDivision2.bind(this);\n\n        this.clearAroundNode = this.clearAroundNode.bind(this);\n        this.randomNumber = this.randomNumber.bind(this);\n        this.state = {\n            grid: [],\n            height: props.height,\n            width: props.width,\n            hold: true,\n            drag: [false, null],\n            current: null,\n            prev: null,\n            solved: false,\n        };\n    }\n\n    componentDidMount() {\n        this.reset(true);\n    }\n\n    // univsited: default;\n\n    reset() {\n        const grid = [];\n        for (let i = 0; i < this.state.height; i++) {\n            const row = [];\n            for (let j = 0; j < this.state.width; j++) {\n                const node = {\n                    row: i,\n                    col: j,\n                    g: 0,\n                    h: 0,\n                    f: 0,\n                    d: 0,\n                    type: \"unvisited\"\n                };\n                if (i === 0 && j === 0) node.type = \"start\";\n                if (i === this.state.height - 1 && j === this.state.width - 1)\n                    node.type = \"end\";\n                row.push(node);\n            }\n            grid.push(row);\n        }\n        this.setState({ grid: grid });\n    }\n \n    // Turn on hover.\n    down = event => {\n        const { solved } = this.state;\n        if (solved) this.resetNodeOfTypes([\"found\"]);\n        this.setState({ hold: false, solved: false });\n    };\n\n    // Turn off hover.\n    up = event => {\n        const { current, grid, drag } = this.state;\n        this.setState({ hold: true });\n        if (drag[0]) {\n            grid[current.row][current.col].type = drag[1];\n            this.setState({ drag: [false, null], grid: grid });\n        }\n    };\n\n    // Lock wall creation while moving the start and end states.\n    lockAll = event => {\n        if (!this.state.drag[0])\n            this.setState({ drag: [true, this.state.current.type] });\n    };\n\n    // Update which node the user is currently hovering.\n    makeCurrent(node) {\n        const { current } = this.state;\n        this.setState({ current: node, prev: current});\n    }\n\n    // ---- Path Finding Algorithms ----\n    \n\n    async dijkstra() { \n        await this.resetNodeOfTypes([\"visited\", \"found\"]);\n        let start = this.getStart();\n        let end = this.getEnd();\n        const { grid } = this.state;\n        let queue = [{ node: start, parent: null }];\n        while(queue.length > 0){\n            let curr = queue.shift();\n            if (curr.node === end) {\n                curr.node.type = \"end\";\n                    curr = curr.parent;\n                    await this.resetNodeOfTypes([\"visited\"]);\n                    while (curr.parent !== null){\n                        curr.node.type = \"found\";\n                        this.setState({ grid });\n                        await this.sleep(10);\n                        curr = curr.parent;\n                    }\n                    this.setState({solved: true});\n                    return;\n            }\n            let neighbors = this.getUnvisitedNeighbors(curr.node, true, false);\n            for (let neighbor of neighbors){\n                if (neighbor.type !== \"visited\") {\n                    if (neighbor.d < curr.node.d + 1) {\n                        neighbor.d = curr.node.d + 1;\n                        let obj = {node: neighbor, parent: curr};\n                        if (queue.includes(obj)) {\n                            this.removeFromArray(queue, neighbor);\n                            queue = [obj, ...queue];\n                        } else {\n                            queue.push(obj);\n                        }\n                    } \n                }\n            }\n            if (curr.node.type !== \"start\") curr.node.type = \"visited\";\n            this.setState({ grid });\n            await this.sleep(10);\n        }\n    }\n\n    async aStar() {\n        await this.resetNodeOfTypes([\"visited\", \"found\"]);\n        const { grid } = this.state;\n        let openSet = [];\n        let closedSet = [];\n        let path = [];\n        let start = this.getStart();\n        let end = this.getEnd();\n\n        openSet.push(start);\n\n        while (openSet.length > 0) {\n            let winner = 0;\n            for (let i = 0; i < openSet.length; i++) {\n                if (openSet[i].f < openSet[winner].f) {\n                    winner = i;\n                }\n            }\n\n            let current = openSet[winner];\n\n            // did it find the end node?\n            if (current === end) {\n                break;\n            }\n\n            this.removeFromArray(openSet, current);\n            closedSet.push(current);\n\n            let neighbors = this.getUnvisitedNeighbors(current, true, false);\n            for (let i = 0; i < neighbors.length; i++) {\n                let neighbor = neighbors[i];\n                // Already seen?\n                if (!closedSet.includes(neighbor)) {\n                    let tempG = current.g + this.heuristic(neighbor, current);\n                    let newPath = false;\n                    if (openSet.includes(neighbor)) {\n                        if (tempG < neighbor.g) {\n                            neighbor.g = tempG;\n                            newPath = true;\n                        }\n                    } else {\n                        neighbor.g = tempG;\n                        newPath = true;\n                        openSet.push(neighbor);\n                    }\n                    if (newPath) {\n                        neighbor.h = this.heuristic(neighbor, end);\n                        neighbor.f = neighbor.g + neighbor.h;\n                        neighbor.previous = current;\n                    }\n                }\n            }\n            this.resetNodeOfTypes([\"path\"]);\n            path = [];\n            let temp = current;\n            path.push(temp);\n            while (temp.previous) {\n                path.push(temp.previous);\n                temp = temp.previous;\n            }\n            for (let node of path) {\n                if (node.type !== \"start\") node.type =\"path\";\n            }\n            this.setState({ grid });\n            await this.sleep(10);\n        }\n        this.resetNodeOfTypes([\"path\"]);\n        for (let i = path.length - 1; i >= 0; i--) {\n            if (path[i].type !== \"start\") path[i].type =\"found\";\n            this.setState({ grid });\n            await this.sleep(10);\n        }\n        this.setState({solved: true});\n    }\n\n    async depthFirstSearch() {\n        await this.resetNodeOfTypes([\"visited\", \"found\"]);\n        const { grid } = this.state;\n        const depthFirstSearchHelper = async (cur, end) => {\n\n            if (cur.node === end) {\n                cur.node.type = \"end\";\n                this.setState({ grid });\n                cur = cur.parent;\n                await this.resetNodeOfTypes([\"visited\"]);\n                while (cur.parent !== null){\n                    cur.node.type = \"found\";\n                    this.setState({ grid });\n                    await this.sleep(10);\n                    cur = cur.parent;\n                }\n                this.setState({solved: true});\n                return null;\n            };\n            let neighbors =  this.getUnvisitedNeighbors(cur.node, true, false);\n            if (neighbors.length === 0 ) return;\n            for(let neighbor of neighbors){\n                neighbor.type = \"visited\";\n                await this.sleep(10);\n                this.setState({ grid });\n                let res = await depthFirstSearchHelper({node: neighbor, parent: cur}, end);\n                if (res === null) return null;\n            }\n        } \n        await depthFirstSearchHelper({node: this.getStart(), parent: null}, this.getEnd());\n\n    }\n\n    async recursiveBacktracking() {\n        await this.resetNodeOfTypes([\"visited\", \"found\", \"wall\"]);\n        const { grid } = this.state;\n        let cur = this.getStart();\n        let stack = [cur];\n        let neighbors = this.getUnvisitedNeighbors(cur, false, false);\n        while (stack.length > 0) {\n            if (neighbors.length > 0) {\n                stack.push(cur);\n                let rand = Math.floor(Math.random() * neighbors.length);\n                cur = neighbors[rand];\n                for (let i = 0; i < neighbors.length; i++) {\n                    if (i !== rand && i !== rand - 1) {\n                        neighbors[i].type = \"wall\";\n                    }\n                }\n                stack.push(cur);\n                cur.type = \"current\";\n                this.setState({ grid: grid });\n                await this.sleep(5);\n                cur.type = \"visited\";\n                this.setState({ grid: grid });\n                neighbors = this.getUnvisitedNeighbors(cur, false, false);\n            } else if (stack.length > 0) {\n                cur = stack.pop();\n                while (\n                    stack.length > 0 &&\n                    this.getUnvisitedNeighbors(cur, false).length === 0\n                ) {\n                    cur = stack.pop();\n                }\n                neighbors = this.getUnvisitedNeighbors(cur, false, false);\n            }\n        }\n        await this.resetNodeOfTypes([\"visited\"]);\n        await this.clearAroundNode(this.getStart());\n        await this.clearAroundNode(this.getEnd());\n    }\n\n    async iterativeRandom() {\n        await this.resetNodeOfTypes([\"visited\", \"found\", \"wall\"]);\n        const { height, width, grid } = this.state;\n        for (let i = 0; i < height; i++) {\n            for (let j = 0; j < width; j++) {\n                if (grid[i][j].type === \"unvisited\" && Math.random() > 0.7)\n                    grid[i][j].type = \"wall\";\n                else if (grid[i][j].type === \"unvisited\")\n                    grid[i][j].type = \"visited\";\n                await this.sleep(1);\n                this.setState({ grid });\n            }\n        }\n        await this.resetNodeOfTypes([\"visited\"]);\n        await this.clearAroundNode(this.getStart());\n        await this.clearAroundNode(this.getEnd());\n    }\n\n    async recursiveDivision2() {\n        await this.resetNodeOfTypes([\"visited\", \"found\", \"wall\"]);\n        const { grid } = this.state;\n        const types = [\"start\", \"end\"];\n     \n        const addEntrance = async () => {\n            const { grid } = this.state;\n            let x = randomNumber(1, grid[0].length - 1);\n            if (!types.includes(grid[grid.length - 1][x])) grid[grid.length - 1][x].type = \"unvisited\";\n            return x;\n        }\n\n        const addInnerWalls = async (h, minX, maxX, minY, maxY, gate) => {\n            if (h) {\n                if (maxX - minX < 2) {\n                    return;\n                }\n\n                let y = Math.floor(randomNumber(minY, maxY)/2)*2;\n                await addHWall(minX, maxX, y);\n\n                await addInnerWalls(!h, minX, maxX, minY, y-1, gate);\n                await addInnerWalls(!h, minX, maxX, y + 1, maxY, gate);\n            } else {\n                if (maxY - minY < 2) {\n                    return;\n                }\n\n                let x = Math.floor(randomNumber(minX, maxX)/2)*2;\n                await addVWall(minY, maxY, x);\n\n                await addInnerWalls(!h, minX, x-1, minY, maxY, gate);\n                await addInnerWalls(!h, x + 1, maxX, minY, maxY, gate);\n            }\n        }\n\n        const addHWall = async (minX, maxX, y) => {\n            let hole = Math.floor(randomNumber(minX, maxX)/2)*2+1;\n            const { grid } = this.state;\n            for (let i = minX; i < maxX; i++) {\n                if (i === hole && types.includes(grid[y][i].type)) grid[y][i].type = \"unvisited\";\n                else if (!types.includes(grid[y][i].type)) grid[y][i].type = \"wall\";\n                this.setState({ grid });\n                await this.sleep(5);\n            }\n        }\n\n         const addVWall = async (minY, maxY, x) => {\n            let hole = Math.floor(randomNumber(minY, maxY)/2)*2+1;\n            const { grid } = this.state;\n            for (let i = minY; i <= maxY; i++) {\n                if (i === hole && !types.includes(grid[i][x].type)) grid[i][x].type = \"unvisited\";\n                else if (!types.includes(grid[i][x].type)) grid[i][x].type = \"wall\";\n                this.setState({ grid });\n                await this.sleep(5);\n            }\n        }\n\n        const randomNumber = (min, max) => {\n            return Math.floor(Math.random() * (max - min + 1) + min);\n        }\n        \n        let ent = await addEntrance();\n        await addInnerWalls(false, 0, grid[0].length, 0, grid.length - 1, ent);\n        await this.clearAroundNode(this.getStart());\n        await this.clearAroundNode(this.getEnd());\n    }\n\n    async recursiveDivision() {\n        await this.resetNodeOfTypes([\"visited\", \"found\", \"wall\"]);\n        const { grid  } = this.state;\n        const buildWall = async (i, j, vert, hori) => {\n            \n            // if no more space to build walls stop.\n            if (vert - i < 3 || hori - j < 3){\n                return;\n            }\n\n            let horiWall = i;\n            let vertWall = j;\n            let vertAndHor = [true, true]\n\n            // Make horizontal wall.\n            horiWall = this.randomNumber(i + 1 , vert - 2 );\n            let leftHole = null;\n            let rightHole = null;\n                \n                // check for the holes in the left and right walls\n            for (let z = i; z < vert; z++ ){\n                if (j > 0 && grid[z][j-1].type === \"unvisited\") leftHole = z;\n                if (hori < grid[0].length && grid[z][hori].type === \"unvisited\") rightHole = z;\n            }\n            let count = 0\n            while ((leftHole !== null && horiWall === leftHole) || (rightHole !== null && horiWall === rightHole)){\n                horiWall = this.randomNumber(i + 1 , vert - 2 );\n                if (count === 3) {\n                    horiWall = null;\n                    vertAndHor[0] = false;\n                    break;\n                }\n                count += 1;\n            }\n            if (horiWall !== null){\n                for (let z = j; z < hori; z++ ){\n                if (grid[horiWall][z].type === \"unvisited\") grid[horiWall][z].type = \"wall\";\n                this.setState({ grid });\n                await this.sleep(1);\n                } \n            }\n                \n            vertWall = this.randomNumber(j + 1, hori - 2 );\n            let topHole = null;\n            let botHole = null;\n\n            for (let z = j; z < hori; z++){\n                if (i > 0 && grid[i-1][z].type === \"unvisited\") topHole = z;\n                if (vert < grid.length && grid[vert][z].type === \"unvisited\") botHole = z;\n            }\n\n            count = 0;\n            while ((topHole !== null && vertWall === topHole) || (botHole !== null && vertWall === botHole)){\n                vertWall = this.randomNumber(j + 1, hori - 2);\n                if (count === 3) {\n                    vertWall = null;\n                    vertAndHor[1] = false;\n                    break;\n                }\n                count += 1;\n            }\n            if (vertWall !== null){\n                for (let z = i; z < vert; z++ ){\n                    if (grid[z][vertWall].type === \"unvisited\") grid[z][vertWall].type = \"wall\";\n                    this.setState({ grid });\n                    await this.sleep(1);\n                }\n            }\n\n            let newHoles = [null, null, null, null];\n            // set the holes.\n            if (vertAndHor[0] && vertAndHor[1]){\n                newHoles[0] = [this.randomNumber(horiWall + 1, vert), vertWall];\n                newHoles[1] = [this.randomNumber(i, horiWall), vertWall];\n                newHoles[2] = [horiWall, this.randomNumber(j, vertWall)];\n                newHoles[3] = [horiWall, this.randomNumber(vertWall + 1, hori)];\n                // Choose 3 walls at random and build a cell hole.\n                newHoles[this.randomNumber(0,4)] = null;\n            } else {\n                if (vertAndHor[0]) newHoles[2] = [horiWall, this.randomNumber(j, hori)];\n                if (vertAndHor[1]) newHoles[0] = [this.randomNumber(i, vert), vertWall];\n            } \n           \n            \n            for (let hole of newHoles) {\n                if (hole !== null) grid[hole[0]][hole[1]].type = \"unvisited\";\n            }\n            this.setState({ grid });\n\n            // leftHole, rightHole, topHole, botHole\n            if (horiWall !== null && vertWall !== null) await buildWall(i, j, horiWall, vertWall);\n            if (horiWall !== null && vertWall !== null) await buildWall(horiWall + 1, vertWall + 1, vert, hori);\n            if (horiWall !== null && vertWall !== null) await buildWall(horiWall + 1, j, vert, vertWall);\n            if (horiWall !== null && vertWall !== null) await buildWall(i, vertWall + 1, horiWall, hori);\n        }\n        await buildWall(0, 0, grid.length, grid[0].length, null, null, null, null);\n    }\n    // Once the End node is found this function computes the shortest path using Breath First Search.\n    async BFS() {\n        await this.resetNodeOfTypes([\"visited\", \"found\"]);\n        let grid = this.state.grid;\n        let end = this.getEnd();\n        let start = this.getStart();\n        let neighbors = this.getUnvisitedNeighbors(start, true, false);\n        let queue = [];\n        for (let neighbor of neighbors){\n                neighbor.type = \"visited\";\n                queue.push({node: neighbor, parent: {node: start, parent: null }});\n        }\n        this.setState({ grid });\n        await this.sleep(10);\n        while (queue.length > 0) {\n            let newQueue = [];\n            for (let curr of queue) {\n                if (curr.node === end){\n                    curr.node.type = \"end\";\n                    curr = curr.parent;\n                    await this.resetNodeOfTypes([\"visited\"]);\n                    while (curr.parent !== null){\n                        curr.node.type = \"found\";\n                        this.setState({ grid });\n                        await this.sleep(10);\n                        curr = curr.parent;\n                    }\n                    this.setState({solved: true});\n                    return;\n                }\n     \n                curr.node.type = \"visited\";\n                neighbors = this.getUnvisitedNeighbors(curr.node, true, false);\n                for (let neighbor of neighbors){\n                    neighbor.type = \"visited\";\n                    newQueue.push({node: neighbor, parent: curr});\n                }\n            }\n            queue = newQueue;\n            this.setState({ grid });\n            await this.sleep(150);\n        }        \n    }\n\n    // ---- helper methods ----\n\n    getStart() {\n        return this.getNode(\"start\");\n    }\n\n    getEnd() {\n        return this.getNode(\"end\");\n    }\n\n    // Rerturn the first node with type passed as an argument.\n    getNode(type) {\n        const { height, width, grid } = this.state;\n        for (let i = 0; i < height; i++) {\n            for (let j = 0; j < width; j++) {\n                if (grid[i][j].type === type) return grid[i][j];\n            }\n        }\n        return null;\n    }\n\n    // Makes the nodes of types, given in a array of types, have type \"unvisited\"\n    async resetNodeOfTypes(types) {\n        const { height, width, grid } = this.state;\n        for (let i = 0; i < height; i++) {\n            for (let j = 0; j < width; j++) {\n                if (types.includes(grid[i][j].type))\n                    grid[i][j].type = \"unvisited\";\n            }\n        }\n        this.setState({ grid });\n    }\n\n    // Make an async function sleep for time in milliseconds.\n    sleep(time) {\n        return new Promise(resolve => setTimeout(resolve, time));\n    }\n\n    // Returns a list of all neighbor nodes that are either univisited, the end node or the start node.\n    getUnvisitedNeighbors(node, includeEnd, includeStart) {\n        let grid = this.state.grid;\n        let neighbors = [];\n        let i = node.row;\n        let j = node.col;\n        let types = [\"unvisited\", \"start\", \"end\"];\n        if (i > 0 && types.includes(grid[i - 1][j].type))\n            neighbors.push(grid[i - 1][j]);\n        if (i < grid.length - 1 &&  types.includes(grid[i + 1][j].type))\n            neighbors.push(grid[i + 1][j]);\n        if (j > 0 &&  types.includes(grid[i][j - 1].type))\n            neighbors.push(grid[i][j - 1]);\n        if (j < grid[0].length - 1 &&  types.includes(grid[i][j + 1].type))\n            neighbors.push(grid[i][j + 1]);\n        for (let neighbor of neighbors){\n            if (!includeEnd && neighbor.type === \"end\") this.removeFromArray(neighbors, neighbor);\n            if (!includeStart && neighbor.type === \"start\") this.removeFromArray(neighbors, neighbor);\n        }\n        \n        return neighbors;\n    }\n\n    async clearAroundNode(node) {\n        const { grid } = this.state;\n        let i  = node.row;\n        let j =  node.col;\n        if (i > 0) grid[i - 1][j].type = \"unvisited\";\n        if (j > 0) grid[i][j - 1].type = \"unvisited\";\n        if (i < grid.length - 1) grid[i + 1][j].type = \"unvisited\";\n        if (j < grid[0].length - 1) grid[i][j + 1].type = \"unvisited\";\n        this.setState({ grid });\n    }\n\n    removeFromArray(arr, elt) {\n        for (let i = arr.length; i >= 0; i--) {\n            if (arr[i] === elt) {\n                arr.splice(i, 1);\n            }\n        }\n    }\n\n    randomNumber(min, max) {\n        return Math.floor(Math.random() * (max - min) + min);\n    }\n\n    // returns an educated guess for the distance between 2 nodes\n    heuristic(a, b) {\n        let ver = Math.abs(a.col - b.col);\n        let hor = Math.abs(a.row - b.row);\n        return Math.sqrt(hor * hor + ver * ver);\n    }\n\n    render() {\n        const { grid, drag, hold } = this.state;\n        return (\n            <table>\n                <tbody\n                    className=\"grid\"\n                    onMouseDown={this.down}\n                    onMouseUp={this.up}\n                >\n                    {grid.map((row, rowIdx) => {\n                        return (\n                            <tr className={\"row\"} key={rowIdx}>\n                                {row.map((node, nodeIdx) => {\n                                    return (\n                                        <Cell\n                                            current={this.makeCurrent}\n                                            drag={drag[0]}\n                                            dragType={drag[1]}\n                                            lockAll={this.lockAll}\n                                            node={node}\n                                            hold={hold}\n                                            key={node.row + \"-\" + node.col}\n                                        ></Cell>\n                                    );\n                                })}\n                            </tr>\n                        );\n                    })}\n                </tbody>\n            </table>\n        );\n    }\n}\n\nexport default Grid;\n","import React from \"react\"\n\nconst Button = (props) => {\n\n    const handleClick = event => {\n        let onClick = props.onClick;\n        let funcName = onClick.name.split(\" \")[1];\n        switch (funcName) {\n            case \"reset\":\n                onClick(false);\n                break;\n            default:\n                onClick();\n                break;\n        }\n        \n    }\n\n    return (\n        <div className=\"button-container\" onClick={handleClick}>\n            <div className=\"button-text\" >{props.text}</div>\n        </div>\n    );\n\n};\n\nexport default Button;","import React from \"react\";\nimport Button from \"./Button\";\n\nclass SideBar extends React.Component {\n    constructor(props) {\n        super(props);\n        this.switchColors = this.switchColors.bind(this);\n        this.state = {};\n    }\n\n    switchColors() {\n        this.swapCSSvar(\"main\");\n        this.swapCSSvar(\"button\");\n        this.swapCSSvar(\"hover\");\n        this.swapCSSvar(\"side\");\n        this.swapCSSvar(\"wall\");\n        this.swapCSSvar(\"accent\");\n    }\n\n    swapCSSvar(property) {\n        let temp = getComputedStyle(document.documentElement).getPropertyValue(\n            \"--\" + property\n        );\n        document.documentElement.style.setProperty(\n            \"--\" + property,\n            getComputedStyle(document.documentElement).getPropertyValue(\n                \"--\" + property + \"1\"\n            )\n        );\n        document.documentElement.style.setProperty(\"--\" + property + \"1\", temp);\n    }\n\n    componentDidUpdate(prevProps) {\n        if (this.props !== prevProps) {\n            const { reset, recursiveBacktracking, depthFirstSearch, aStar, dijkstra, iterativeRandom, BFS, recursiveDivision, recursiveDivision2 } = this.props;\n            this.setState({\n                BFS,\n                reset,\n                recursiveBacktracking,\n                depthFirstSearch,\n                aStar,\n                dijkstra,\n                iterativeRandom,\n                recursiveDivision,\n                recursiveDivision2,\n            });\n        }\n    }\n\n    render() {\n        const {\n            reset,\n            recursiveBacktracking,\n            dijkstra,\n            aStar,\n            depthFirstSearch,\n            iterativeRandom,\n            BFS,\n            recursiveDivision,\n            recursiveDivision2,\n        } = this.state;\n        return (\n            <div className=\"side-bar\">\n                <div className=\"section\">\n                    <div className=\"section-text\">Controls</div>\n\n                    <Button\n                        onClick={reset}\n                        text={\"Reset\"}\n                    ></Button>\n                    <Button\n                        onClick={this.switchColors}\n                        text={\"Dark/Light Mode\"}\n                    ></Button>\n                </div>\n                <div className=\"section\">\n                    <div className=\"section-text\">Path Finders</div>\n                    <Button\n                        onClick={BFS}\n                        text={\"Breath First Search\"}\n                    ></Button>\n                    <Button\n                        onClick={dijkstra}\n                        text={\"Dijkstra's algorithm\"}\n                    ></Button>\n                    <Button\n                        onClick={aStar}\n                        text={\"A* algorithm\"}\n                    ></Button>\n                    <Button\n                        onClick={depthFirstSearch}\n                        text={\"Detph First Search\"}\n                        \n                    ></Button>\n                </div>\n                <div className=\"section\">\n                    <div className=\"section-text\">Maze Generators</div>\n                    <Button\n                        onClick={recursiveDivision}\n                        text={\"Recursive Division\"}\n                    ></Button>\n                    <Button\n                        onClick={recursiveDivision2}\n                        text={\"Recursive Division 2\"}\n                    ></Button>\n                    <Button\n                        onClick={recursiveBacktracking}\n                        text={\"Recursive Random\"}\n                    ></Button>\n                    <Button\n                        onClick={iterativeRandom}\n                        text={\"Iterative Random\"}\n                    ></Button>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default SideBar;\n","import React from \"react\";\n\nconst Tutorial = props => {\n    return (\n        <div className=\"tutorial\">\n            <div className=\"title-container\">\n                <div className=\"title\">\n                    Path <br /> Finder\n                </div>\n            </div>\n\n            <div className=\"section\">\n                <div className=\"section-text\">Step 1</div>\n                <div className=\"section-instruction\">\n                    Draw a maze by holding down your mouse on the gird.\n                </div>\n            </div>\n            <div className=\"section\">\n                <div className=\"section-text\">Step 2</div>\n                <div className=\"section-instruction\">\n                    Drag and drop the start (green) and end (red) cells on the grid.\n                </div>\n            </div>\n            <div className=\"section\">\n                <div className=\"section-text\">Step 3</div>\n                <div className=\"section-instruction\">\n                    Click on the algorithm that you want to run!\n                </div>\n            </div>\n        </div>\n    );\n};\n\nexport default Tutorial;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Grid from \"./Grid\";\nimport SideBar from \"./SideBar\";\nimport Tutorial from \"./Tutorial\";\n\nlet size = 25;\n\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n        this.ref = React.createRef();\n        let width = window.innerWidth - 450;\n        let height = window.innerHeight ;\n        this.state = {\n            width: Math.floor(width / size) - 1,\n            height: Math.floor(height / size) - 1,\n            margin: (height - size * (Math.floor(height / size)- 1)) / 2,\n        };\n    }\n\n    componentDidMount() {\n        const { reset, recursiveBacktracking, depthFirstSearch, aStar, dijkstra, iterativeRandom, BFS, recursiveDivision, recursiveDivision2 } = this.ref.current;\n        this.setState({\n            reset: reset,\n            recursiveBacktracking: recursiveBacktracking,\n            depthFirstSearch: depthFirstSearch,\n            aStar: aStar,\n            dijkstra: dijkstra,\n            iterativeRandom: iterativeRandom,\n            BFS: BFS,\n            recursiveDivision: recursiveDivision,\n            recursiveDivision2: recursiveDivision2,\n        });\n    }\n\n    render() {\n        const { margin, height, width, reset, recursiveBacktracking, depthFirstSearch, aStar, dijkstra, iterativeRandom, BFS, recursiveDivision, recursiveDivision2 } = this.state;\n        return (\n            <div style={ {margin }} className=\"container\">\n                <Tutorial></Tutorial>\n                <Grid  height={height} width={width} ref={this.ref}></Grid>\n                <SideBar reset={reset} recursiveBacktracking={recursiveBacktracking} dijkstra={dijkstra} depthFirstSearch={depthFirstSearch} aStar={aStar} iterativeRandom={iterativeRandom} BFS={BFS} recursiveDivision={recursiveDivision} recursiveDivision2={recursiveDivision2}></SideBar>\n            </div>\n        );\n    }\n}\n\nReactDOM.render(<App />, document.querySelector(\"#root\"));\n"],"sourceRoot":""}